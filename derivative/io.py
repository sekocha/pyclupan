#!/usr/bin/env python
import numpy as np
import argparse
import joblib
import glob, os
import time
import copy

from mlptools.common.structure import Structure

from pyclupan.common.io.yaml import Yaml
from pyclupan.derivative.derivative import DSSet
from pyclupan.derivative.derivative import DSSample

def get_file_list(inputs):

    files = []
    for f in inputs:
        files.extend(glob.glob(f))
    files = sorted(set(files))
    return files

def print_poscar_tofile(supercell, 
                        n_atoms, 
                        order, 
                        elements,
                        remove_indices=[],
                        filename='POSCAR'):

    f = open(filename, 'w')
    print('generated by pyclupan', file=f)
    print('1.0', file=f)
    for n in supercell.axis.T:
        print("  ", "{0:15.15f}".format(n[0]),
                    "{0:15.15f}".format(n[1]),
                    "{0:15.15f}".format(n[2]), file=f)

    # remove_indices must be sorted
    if len(remove_indices) > 0:
        positions = supercell.positions[:,order]
        for idx in remove_indices:
            begin = int(np.sum(n_atoms[:idx]))
            end = begin + n_atoms[idx]
            positions = np.delete(positions,
                                  range(begin,end), 
                                  axis=1)
            n_atoms = np.delete(n_atoms, idx)
    else:
        positions = supercell.positions[:,order]

    print(' ', '  '.join(elements), file=f)
    print(' ', '  '.join([str(n) for n in n_atoms]), file=f)
    print('Direct', file=f)
    for n in positions.T:
        print("  ", "{0:15.15f}".format(float(n[0])),
                    "{0:15.15f}".format(float(n[1])),
                    "{0:15.15f}".format(float(n[2])), file=f)
    f.close()
 
if __name__ == '__main__':

    ps = argparse.ArgumentParser()
    ps.add_argument('--dump',
                    type=str,
                    nargs='*',
                    default=None,
                    help='parse derivative*.pkl file')
    ps.add_argument('--yaml',
                    type=str,
                    nargs='*',
                    default=None,
                    help='parse derivative*.yaml file')
    ps.add_argument('-r',
                    '--random',
                    type=int,
                    default=None,
                    help='number of random samples')
    ps.add_argument('--n_cell_ub',
                    type=int,
                    default=None,
                    help='Maximum number of cells')
    ps.add_argument('-e',
                    '--elements',
                    nargs='*',
                    type=str,
                    default=None,
                    help='elements')
    ps.add_argument('--no_poscars',
                    action='store_true',
                    help='Only derivative-all.pkl is generated.\
                          No poscar files are generated.')
 
    args = ps.parse_args()

    if args.dump is None and args.yaml is None:
        files = glob.glob('derivative*.pkl')
        dump = True
    elif args.dump is not None:
        files = get_file_list(args.dump)
        files = []
        for f in args.dump:
            files.extend(glob.glob(f))
        files = sorted(set(files))
        dump = True
    else:
        files = get_file_list(args.yaml)
        dump = False

    if 'derivative-all.pkl' in files:
        files.remove('derivative-all.pkl')
    print(' files =', files)

    ds_set_all = []
    if dump == False:
        yaml = Yaml()
        for f in files:
            ds_set_all.extend(yaml.parse_derivative_yaml(filename=f))
    else:
        for f in files:
            ds_set_all.extend(joblib.load(f))

    n_st = sum([ds_set.n_labelings for ds_set in ds_set_all])
    print(' total number of structures =', n_st)

    #joblib.dump(ds_samp, 'derivative-all.pkl', compress=3)
    joblib.dump(ds_set_all, 'derivative-all.pkl', compress=3)
    ds_samp = DSSample(ds_set_all)

    if args.no_poscars == False:
        if args.random is not None:
            st_attr, indices = ds_samp.sample_random(k=args.random)
        else:
            st_attr, indices = ds_samp.sample_all(n_cell_ub=args.n_cell_ub)
        n_samples = len(st_attr)
        print(' total number of sampled structures =', n_samples)

        if args.elements is None:
            strings = 'ABCDEFGHIJK'
            elements = [strings[e] for e in ds_set_all[0].elements]
        else:
            elements = args.elements

        remove_indices = [i for i, e in enumerate(elements) 
                            if e == 'vac' or e == 'Vac' or e == 'VAC']
        remove_indices = sorted(remove_indices, reverse=True)
        for idx in remove_indices:
            del elements[idx]

        dir1 = 'derivative_poscars/'
        os.makedirs(dir1, exist_ok=True)

        n_div = int(np.ceil(n_samples/1000))
        indices_split = np.array_split(range(n_samples), n_div)
        for i, div in enumerate(indices_split):
            print(' generating poscars ... step:', i + 1, '...')
            dir2 = dir1 + str(i+1).zfill(5) + '/'
            os.makedirs(dir2, exist_ok=True)
            for j in div:
                order, n_atoms = st_attr[j]
                n_cell, g_id, s_id, l_id = indices[j]

                fname = dir2 + 'POSCAR-' + str(n_cell) + '-' \
                             + str(s_id) + '-' + str(l_id)
                cell = ds_set_all[g_id].get_supercell_from_id(s_id)
                print_poscar_tofile(cell, 
                                    n_atoms, 
                                    order, 
                                    elements,
                                    remove_indices=remove_indices,
                                    filename=fname)

   
