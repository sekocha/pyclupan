#!/usr/bin/env python
import numpy as np
import argparse
import joblib
import glob, os
import time
import copy

from mlptools.common.structure import Structure

from pyclupan.common.io.yaml import Yaml
from pyclupan.derivative.derivative import DSSet
from pyclupan.derivative.derivative import DSSample

def get_file_list(inputs):

    files = []
    for f in inputs:
        files.extend(glob.glob(f))
    files = sorted(set(files))
    return files

def print_poscar_tofile(supercell, 
                        n_atoms, 
                        order, 
                        elements,
                        remove_indices=[],
                        filename='POSCAR'):

    f = open(filename, 'w')
    print('generated by pyclupan', file=f)
    print('1.0', file=f)
    for n in supercell.axis.T:
        print("  ", "{0:15.15f}".format(n[0]),
                    "{0:15.15f}".format(n[1]),
                    "{0:15.15f}".format(n[2]), file=f)

    # remove_indices must be sorted
    if len(remove_indices) > 0:
        positions = supercell.positions[:,order]
        for idx in remove_indices:
            begin = int(np.sum(n_atoms[:idx]))
            end = begin + n_atoms[idx]
            positions = np.delete(positions,
                                  range(begin,end), 
                                  axis=1)
            n_atoms = np.delete(n_atoms, idx)
    else:
        positions = supercell.positions[:,order]

    print(' ', '  '.join(elements), file=f)
    print(' ', '  '.join([str(n) for n in n_atoms]), file=f)
    print('Direct', file=f)
    for n in positions.T:
        print("  ", "{0:15.15f}".format(float(n[0])),
                    "{0:15.15f}".format(float(n[1])),
                    "{0:15.15f}".format(float(n[2])), file=f)
    f.close()
 
if __name__ == '__main__':

    ps = argparse.ArgumentParser()
    ps.add_argument('--dump',
                    type=str,
                    default=None,
                    help='parse derivative*.pkl file')
    ps.add_argument('--yaml',
                    type=str,
                    default=None,
                    help='parse derivative*.yaml file')
    ps.add_argument('-e',
                    '--elements',
                    nargs='*',
                    type=str,
                    default=None,
                    help='elements')
    ps.add_argument('-i',
                    '--id',
                    nargs=3,
                    type=int,
                    default=None,
                    required=True,
                    help='structure id')
 
    args = ps.parse_args()

    if args.dump is not None:
        ds_set_all = joblib.load(args.dump)
    elif args.yaml is not None:
        ds_set_all = Yaml().parse_derivative_yaml(args.yaml)

    n_st = sum([ds_set.n_labelings for ds_set in ds_set_all])
    print(' total number of structures =', n_st)

    ds_samp = DSSample(ds_set_all)

    """
        In the current implementation, g_id = s_id 
        when parsing a yaml/pkl file including structures 
        with a single n_cell
    """
    g_id, s_id, l_id = args.id[1], args.id[1], args.id[2]
    st_attr, indices = ds_samp.sample_single(g_id, s_id, l_id)

    if args.elements is None:
        strings = 'ABCDEFGHIJK'
        elements = [strings[e] for e in ds_set_all[0].elements]
    else:
        elements = args.elements

    remove_indices = [i for i, e in enumerate(elements) 
                        if e == 'vac' or e == 'Vac' or e == 'VAC']
    remove_indices = sorted(remove_indices, reverse=True)
    for idx in remove_indices:
        del elements[idx]

    order, n_atoms = st_attr[0]
    n_cell, g_id, s_id, l_id = indices[0]

    fname = 'poscar-' + str(n_cell) + '-' + str(s_id) + '-' + str(l_id)
    cell = ds_set_all[g_id].get_supercell_from_id(s_id)
    print_poscar_tofile(cell, 
                        n_atoms, 
                        order, 
                        elements,
                        remove_indices=remove_indices,
                        filename=fname)

